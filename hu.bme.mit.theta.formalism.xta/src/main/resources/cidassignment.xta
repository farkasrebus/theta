/************************
** PARAMETER DECLARATIONS
** modifiable part
************************/

/************************
** Structural parameters
************************/

// number of ETHs
const int nEths = 2;
// number of LIOs
const int nLios := 2;
// number of units
const int nUnits := nLios + nEths;

// capacity of the communication channel
const int capacity = 5;

/************************
** Time parameters
************************/

// maximal time spent in Off state
const int tOff = 0;
// period of sending NORMAL messages
const int tSync = 3;
// timeout for Slave state
const int tSlave = 7;
// period of sending SEARCH messages
const int tSearch = 15;

// minimal propagation time for messages
const int tPropMin = 0;
// maximal propagation time for messages
const int tPropMax = 0;


/************************
** INTERNAL DECLARATIONS
** do not modify
************************/


/************************
** Type definitions
************************/

// logical ID type for dispatching messages
typedef int[0, nUnits - 1] Id;
// logical ID type with invalid (-1) value
typedef int[-1, nUnits - 1] ExtendedId;
// logical ID type for EHTs
typedef int[0, nEths - 1] EthId;
// logical ID type for LIOs
typedef int[nEths, nUnits - 1] LioId;

// message index type for channel model
typedef int[0, capacity - 1] MsgIndex;

// possible message types
typedef int[0, 3] MsgType;

// array type for storing recipients of a message
typedef bool MsgRecipients[Id];

// message type
typedef struct {
	MsgType type;
	ExtendedId hwid;
	ExtendedId cid;
} Msg;

/************************
** Synchronization
************************/

// send message
chan send;
// receive message
chan receive[Id];

/************************
** Global variables
************************/

// recipients of the message to send
MsgRecipients recipients;
// message sent or received
Msg msg;

/************************
** Macros
************************/

const MsgType Normal = 0;
const MsgType Assign = 1;
const MsgType Search = 2;
const MsgType Login = 3;

// send message : initialize msg
void sendMsg(MsgType type, ExtendedId hwid, ExtendedId cid) {
	msg.type = type;
	msg.hwid =  hwid;
	msg.cid = cid;
}

process Eth(EthId this, Id hwid, EthId cid) {
/************************
** INTERNAL DECLARATIONS
** do not modify
************************/

/************************
** Local variables
************************/

// clock for scheduling NORMAL messages
clock syncTimer;
// clock for any other tasks
clock ethTimer;

// flag to indicate if the unit is a master
bool master;
// CID table - assigns hadware ID-s to CID-s
ExtendedId table[LioId];

// temporal variable for storing newly calculated cid
ExtendedId tmp;

/************************
** Macros
************************/

// initialize cid table
void initTable() {
	for (lioId : LioId) {
		table[lioId] = -1;
	}
}

// send NORMAL
void sendNormal() {
	sendMsg(Normal, -1, cid);
}

// send SEARCH
void sendSearch() {
	sendMsg(Search, -1, -1);
}

// send ASSIGN(recipientHwId, recipientCid)
void sendAssign(Id recipientHwId, LioId recipientCid) {
	sendMsg(Assign, recipientHwId, recipientCid);
}

// search cid table for hwid and return index (cid)
ExtendedId search(ExtendedId hwid) {
	for (lioId : LioId) {
		if (table[lioId] == hwid) {
			return lioId;
		}
	}
	return -1;
}

// calculate new cid
ExtendedId newCid(LioId hwid, ExtendedId oldCid) {
	ExtendedId ethCid = search(hwid);

	// if hwid is assigned in the cid table
	if (ethCid != -1) {
		// return corresponding cid value
		return ethCid;
	}

	// else if LIO already had a cid
	if (oldCid != -1) {
		// return old cid value
		return oldCid;
	}

	// else return first unassigned cid (if any)
	return search(-1);
}

// update cid table
void update(LioId hwid, ExtendedId cid) {
	if (cid != -1) {
		for (lioId : LioId) {
			if (table[lioId] == hwid) {
				table[lioId] = -1;	
			}
		}
		table[cid] = hwid;
	}
}



// send to all
void toAll() {
	for (id : Id) {
		if (id != this) {
			recipients[id] = true;
		} else {
			recipients[id] = false;
		}
	}
}

// send to all ETHs
void toAllEths() {
	for (id : EthId) {
		if (id != this) {
			recipients[id] = true;
		} else {
			recipients[id] = false;
		}
	}
	for (id : LioId) {
		recipients[id] = false;
	}
}
state
    S0,
    Master_received,
    Slave_received,
    Master_waiting {syncTimer <= tSync &&
ethTimer <= tSearch},
    Slave_waiting {syncTimer <= tSync &&
ethTimer <= tSlave},
    Off {ethTimer <= tOff};
commit
    S0,
    Master_received,
    Slave_received;
init Off;
trans
    S0 -> Off {  },
    Off -> S0 { sync receive[this]?;  },
    Master_waiting -> Master_waiting { guard ethTimer >= tSearch; sync send!; assign sendSearch(),
toAll(),
ethTimer = 0;  },
    Master_received -> Master_waiting { guard msg.type == Login; sync send!; assign tmp = newCid(msg.hwid, msg.cid),
update(msg.hwid, tmp),
sendAssign(msg.hwid, tmp),
toAll();  },
    Slave_received -> Slave_waiting { guard msg.type == Assign; assign update(msg.hwid, msg.cid);  },
    Slave_received -> Slave_waiting { guard msg.type == Login ||
msg.type == Search;  },
    Master_received -> Master_waiting { guard msg.type == Assign ||
msg.type == Search;  },
    Master_received -> Master_waiting { guard msg.type == Normal &&
cid <= msg.cid;  },
    Master_received -> Slave_waiting { guard msg.type == Normal &&
cid > msg.cid; assign master = false,
ethTimer = 0;  },
    Master_waiting -> Master_received { sync receive[this]?;  },
    Slave_received -> Slave_waiting { guard msg.type == Normal &&
cid > msg.cid; assign ethTimer = 0;  },
    Slave_received -> Slave_waiting { guard msg.type == Normal &&
cid <= msg.cid;  },
    Slave_waiting -> Slave_received { sync receive[this]?;  },
    Master_waiting -> Master_waiting { guard syncTimer >= tSync; sync send!; assign sendNormal(),
toAllEths(),
syncTimer = 0;  },
    Slave_waiting -> Slave_waiting { guard syncTimer >= tSync; sync send!; assign sendNormal(),
toAllEths(),
syncTimer = 0;  },
    Slave_waiting -> Master_waiting { guard ethTimer >= tSlave; assign master = true,
ethTimer = 0;  },
    Off -> Slave_waiting { guard ethTimer <= tOff; assign initTable(),
master = false,
syncTimer = 0,
ethTimer = 0;  };
}

process Channel() {
/************************
** INTERNAL DECLARATIONS
** do not modify
************************/

/************************
** Local variables
************************/

// timer for stored messages
clock pendingTimer[MsgIndex];


// stored messages
Msg pendingMsg[MsgIndex];
// recipients of stored messages
MsgRecipients pendingRecipients[MsgIndex];

// temporal variable
MsgIndex index;

/************************
** Macros
************************/

// true iff pendingMsg[i] is empty
bool empty(MsgIndex i) {
	return forall (id : Id) !pendingRecipients[i][id];
}
state
    Received,
    Waiting {forall (i : MsgIndex) (empty(i) || pendingTimer[i] <= tPropMax)};
commit
    Received;
init Waiting;
trans
    Waiting -> Received { select i : MsgIndex; guard empty(i) &&
(forall (j : MsgIndex) (!empty(j) || j >= i)); sync send?; assign index = i;  },
    Received -> Waiting { assign pendingRecipients[index] = recipients,
pendingMsg[index] = msg,
pendingTimer[index] = 0;  },
    Waiting -> Waiting { select i : MsgIndex, id : Id; guard pendingRecipients[i][id] &&
pendingTimer[i] >= tPropMin; sync receive[id]!; assign pendingRecipients[i][id] = false,
msg = pendingMsg[i];  };
}

process Lio(LioId this, Id hwid) {
/************************
** INTERNAL DECLARATIONS
** do not modify
************************/

/************************
** Local variables
************************/

// timer for measuring time spent in state Off
clock lioTimer;

// assigned cid value
ExtendedId cid = -1;

/************************
** Macros
************************/

// send LOGIN(cid)
void sendLogin(ExtendedId cid) {
	sendMsg(Login, hwid, cid);
}

// send to all ETHs
void toAllEths() {
	for (id : EthId) {
		recipients[id] = true;
	}
	for (id : LioId) {
		recipients[id] = false;
	}
}
state
    S0,
    Off {lioTimer <= tOff},
    Received,
    Waiting;
commit
    S0,
    Received;
init Off;
trans
    Received -> Waiting { guard msg.type == Assign &&
msg.hwid != hwid;  },
    S0 -> Off {  },
    Off -> S0 { sync receive[this]?;  },
    Off -> Waiting { guard lioTimer >= tOff; assign cid = -1;  },
    Received -> Waiting { guard msg.type == Assign &&
msg.hwid == hwid; assign cid = msg.cid;  },
    Received -> Waiting { guard msg.type == Search; sync send!; assign sendLogin(cid),
toAllEths();  },
    Waiting -> Received { sync receive[this]?;  };
}
/************************
** SYSTEM DECLARATIONS
** modifiable part
************************/

/************************
** Template instantiations
************************/

channel = Channel();
eth0 = Eth(0, 0, 0);
eth1 = Eth(1, 1, 1);
lio2 = Lio(2, 2);
lio3 = Lio(3, 3);

/************************
** System composition
************************/

system channel, eth0, eth1, lio2, lio3;